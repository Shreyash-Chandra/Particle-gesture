<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #333;
            border-radius: 10px;
            overflow: hidden;
            opacity: 0.7;
            z-index: 10;
        }
        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror the webcam */
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffcc;
            pointer-events: none;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 1.5rem; text-transform: uppercase; letter-spacing: 2px; }
        p { margin: 5px 0; font-size: 0.9rem; color: #aaa; }
        .gesture-box {
            margin-top: 15px;
            background: rgba(0, 255, 204, 0.1);
            padding: 10px;
            border-left: 3px solid #00ffcc;
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            text-align: center;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui">
        <h1>Particle Morph</h1>
        <p>Current Shape: <span id="shape-name" style="color:white; font-weight:bold;">Sphere</span></p>
        <div class="gesture-box">
            <strong>Controls:</strong><br>
            âœ‹ <b>Move Hand:</b> Attract/Repel Particles<br>
            ðŸ‘Œ <b>Pinch (Index+Thumb):</b> Switch Shape<br>
        </div>
    </div>

    <div id="loading">Initializing Camera & AI...<br><small>Please allow camera access</small></div>

    <div id="video-container">
        <video id="input-video"></video>
    </div>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 15000;
    const PARTICLE_SIZE = 0.15;
    const INTERACTION_RADIUS = 30; // Radius of hand influence
    
    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- PARTICLE SYSTEM ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3); // Where particles want to go
    const originalColors = []; // Store base colors for restoration

    // Initialize with random positions
    const colorObj = new THREE.Color();
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const x = (Math.random() - 0.5) * 100;
        const y = (Math.random() - 0.5) * 100;
        const z = (Math.random() - 0.5) * 100;

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        targetPositions[i * 3] = x;
        targetPositions[i * 3 + 1] = y;
        targetPositions[i * 3 + 2] = z;

        // Base color (cyan/blue/purple mix)
        colorObj.setHSL(0.5 + Math.random() * 0.2, 0.8, 0.6);
        colors[i * 3] = colorObj.r;
        colors[i * 3 + 1] = colorObj.g;
        colors[i * 3 + 2] = colorObj.b;
        
        originalColors.push({r: colorObj.r, g: colorObj.g, b: colorObj.b});
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- SHAPE GENERATORS (MATH) ---
    const shapes = {
        sphere: (i) => {
            const r = 20;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        },
        heart: (i) => {
            // Heart surface formula
            const r = 1.2; 
            const theta = Math.random() * Math.PI * 2; // 0 to 2PI
            const phi = Math.random() * Math.PI; // 0 to PI
            
            // Parametric equations for a 3D heart
            // x = 16sin^3(t)
            // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
            // We adapt this to 3D by rotating roughly around Y
            
            // Simplified Heart Volume
            const x = 16 * Math.pow(Math.sin(phi), 3);
            const y = 13 * Math.cos(phi) - 5 * Math.cos(2*phi) - 2 * Math.cos(3*phi) - Math.cos(4*phi);
            const z = x * Math.sin(theta) * 0.5; // Thickness
            const finalX = x * Math.cos(theta);

            return { x: finalX * r, y: y * r, z: z * r };
        },
        saturn: (i) => {
            const isRing = Math.random() > 0.6; // 40% planet, 60% ring
            if (!isRing) {
                // Planet
                const r = 12;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                return {
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                };
            } else {
                // Ring
                const r = 20 + Math.random() * 15; // Inner radius 20, outer 35
                const theta = Math.random() * Math.PI * 2;
                return {
                    x: r * Math.cos(theta),
                    y: (Math.random() - 0.5) * 1, // Flat ring
                    z: r * Math.sin(theta)
                };
            }
        },
        flower: (i) => {
            const rBase = 25;
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI;
            // Rose curve logic wrapped on sphere
            const k = 4; 
            const r = rBase * Math.cos(k * u) * Math.sin(v);
            return {
                x: r * Math.cos(u) * Math.sin(v),
                y: r * Math.sin(u) * Math.sin(v),
                z: r * Math.cos(v)
            };
        },
        fireworks: (i) => {
            // Explosion outward
             const r = Math.random() * 40;
             const theta = Math.random() * Math.PI * 2;
             const phi = Math.acos((Math.random() * 2) - 1);
             return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
             };
        }
    };

    let currentShapeKey = 'sphere';
    const shapeKeys = Object.keys(shapes);
    
    function transformToShape(shapeName) {
        currentShapeKey = shapeName;
        document.getElementById('shape-name').innerText = shapeName.charAt(0).toUpperCase() + shapeName.slice(1);
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const pos = shapes[shapeName](i);
            targetPositions[i * 3] = pos.x;
            targetPositions[i * 3 + 1] = pos.y;
            targetPositions[i * 3 + 2] = pos.z;
        }
    }

    // Initial shape
    transformToShape('sphere');

    // --- INTERACTION LOGIC ---
    let handPos = new THREE.Vector3(0, 0, 0);
    let isHandPresent = false;
    let isPinching = false;
    let lastPinchTime = 0;

    // --- MEDIAPIPE SETUP ---
    const videoElement = document.getElementById('input-video');
    
    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isHandPresent = true;
            const landmarks = results.multiHandLandmarks[0];

            // 1. Map Hand Position (Index Finger Tip is index 8) to 3D Space
            // Coordinates are normalized [0,1]. We map to approximate screen space at z=0
            const x = (1 - landmarks[8].x) * 2 - 1; // Flip X for mirror effect
            const y = -(landmarks[8].y * 2 - 1);
            
            // Project into 3D world (roughly)
            const vector = new THREE.Vector3(x, y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            handPos.copy(pos);

            // 2. Detect Pinch (Thumb Tip 4 & Index Tip 8)
            const thumb = landmarks[4];
            const index = landmarks[8];
            const dist = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));

            // Pinch threshold
            if (dist < 0.05) {
                if (!isPinching && Date.now() - lastPinchTime > 1000) {
                    // Trigger shape switch
                    let currentIndex = shapeKeys.indexOf(currentShapeKey);
                    let nextIndex = (currentIndex + 1) % shapeKeys.length;
                    transformToShape(shapeKeys[nextIndex]);
                    lastPinchTime = Date.now();
                }
                isPinching = true;
            } else {
                isPinching = false;
            }

        } else {
            isHandPresent = false;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    cameraUtils.start();


    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const positionsArr = particles.geometry.attributes.position.array;
        const colorsArr = particles.geometry.attributes.color.array;

        // Auto-rotation of the whole system
        particles.rotation.y += 0.002;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const px = i * 3;
            const py = i * 3 + 1;
            const pz = i * 3 + 2;

            // 1. Morphing: Lerp towards target shape
            // Ease factor determines speed of morphing
            const lerpSpeed = 0.05;
            positionsArr[px] += (targetPositions[px] - positionsArr[px]) * lerpSpeed;
            positionsArr[py] += (targetPositions[py] - positionsArr[py]) * lerpSpeed;
            positionsArr[pz] += (targetPositions[pz] - positionsArr[pz]) * lerpSpeed;

            // 2. Interactive: Hand influence
            if (isHandPresent) {
                // Calculate distance from particle to hand in local space
                // We need to account for the object's rotation to get accurate world space dist
                const particlePos = new THREE.Vector3(positionsArr[px], positionsArr[py], positionsArr[pz]);
                particlePos.applyMatrix4(particles.matrixWorld);

                const dist = particlePos.distanceTo(handPos);

                if (dist < INTERACTION_RADIUS) {
                    // Repulsion vector
                    const force = 1 - (dist / INTERACTION_RADIUS);
                    const dx = particlePos.x - handPos.x;
                    const dy = particlePos.y - handPos.y;
                    const dz = particlePos.z - handPos.z;

                    // Push away
                    positionsArr[px] += dx * force * 0.2;
                    positionsArr[py] += dy * force * 0.2;
                    positionsArr[pz] += dz * force * 0.2;

                    // Change color to hot pink/red near hand
                    colorsArr[px] = 1.0;
                    colorsArr[py] = 0.0;
                    colorsArr[pz] = 0.5;
                } else {
                    // Restore color slowly
                    colorsArr[px] += (originalColors[i].r - colorsArr[px]) * 0.05;
                    colorsArr[py] += (originalColors[i].g - colorsArr[py]) * 0.05;
                    colorsArr[pz] += (originalColors[i].b - colorsArr[pz]) * 0.05;
                }
            } else {
                 // Restore color immediately if no hand
                colorsArr[px] += (originalColors[i].r - colorsArr[px]) * 0.05;
                colorsArr[py] += (originalColors[i].g - colorsArr[py]) * 0.05;
                colorsArr[pz] += (originalColors[i].b - colorsArr[pz]) * 0.05;
            }
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;

        renderer.render(scene, camera);
    }

    // Handle Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>